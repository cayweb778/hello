# 租户设计
- 国际通用的《租户概念》,即我们的账套概念 
- 标识：tenantId（bjxgkj-001-2020）

- 国人的系统框架,例:el-admin,spring blade,jeecgboot等都涉及租户


- 租户设计（tenantId）已知两种方式：

  - 多数据源方式（多数据库架构）：
    - 特性：
      - tenantId（bjxgkj-001-2020）即数据库架构名
      - r2dbc动态数据源切换
      - axios api层封装
      - 多数据库架构
    - 优点：完全独立
    - 缺点：数据不一致，冗余性（代码、表。。。）
  ---
  - 【最优方案】单数据库架构（补充字段）：
      - 优点
        - 分表设计更利于数据库性能调优
        - 数据一致
        - 不冗余
        - 简化逻辑
        - 单数据库架构连接池
    - 特性：
    
        - axios api层封装
        - 分表设计

        - 方式1：自动补充字段
            - tenantId即所有表字段，值为“bjxgkj-001-2020”
            - r2dbc自动补充tenantId字段（tenantId='bjxgkj-001-2020'）
            - 这个查阅资料，应该实现起来不容易
            - 设计《数据审计》与运维的逻辑业务，需要前期的工作量
                - 功能:
                    - 导出租户为一个完整架构
                    - 导出租户为一个完整架构sql / 数据库文件
                    - 生成一个租户接口
                    - 导入一个租户接口
                    - 创建为公司各年度的每个数据库架构，
                    - 创建为公司数据库架构（年度合并），
                    - 删除年度，或者删除。。
      
    - 方式2：用户模式
        - 如果说能限定用户查看的数据行，就可以很简单解决该问题

  
- 而账套概念应该只局限于财务会计行业
---

## 当前设计
-  多数据库架构实现租户
  - 特性
    - r2dbc动态数据源切换
    - axios api层封装
    - 多数据库架构
  
  - 优点
    - 租户完全独立
  - 缺点
    - 数据不一致，冗余性


## 计划设计
-  单数据库架构实现租户
  - 特性
    - r2dbc抽象接口补充租户字段sql
    - 单数据库架构
  - 缺点
    - 对于完全独立要设计逻辑业务接口
  - 优点
    - 数据一致，不冗余
---

# 概要
- 从头开始思考，如果说我们不是做多个模式，而是对某些表进行 （公司+年度） 分表操作

---

# 眼下准备解决方案
- [【方案2】 ](#jump1)

---
    
# <span id="jump2">最优方案（单数据库区分作用域）</span>
### 概述
- 单数据库区分作用域
- 该方式之前如果不分表 部分累加表（凭证）有严重性能问题
- 如果手动分表逻辑有很多影响
- 而postgres提供的分表功能完全解耦合，不影响逻辑

### 特性

- 完全数据一致性
- 更轻松的数据量性能调优（postgre分区规则）
- 运维与开发分离
    - 运维可通过账套接口得到想要的数据条件
    - 开发始终在单数据库架构操作
- 账套接口解决维护各种问题以及账套接口

### 完成账套接口：
- 逻辑
    - 获取所有表数据，过滤条件: 所有表的的条件字段，导出sql,或创建为实际数据库（运维实施）
- 实现的功能:
    - 生成账套接口
    - 导入账套
    - 导出sql或导出数据库文件
    - 创建为公司各年度的每个数据库
    - 创建为公司数据库（年度合并）
    - 删除年度，或者删除
- 特性
    - 新增账套
    - 导入账套
    - 年度账审计
    - 删除账套
    - 导出sql

---
# 随时间增加数据量的表
    - 凭证表
    - 回滚表
    - 任务管理
    - 日志管理
    - 科目表

## 也许相较现在的模式，我们减少了
- 多数据库字段不一致的情况
- 减少了所有开发人员对跨模式的思考，
- 减少了架构逻辑性，减少了做封装工具类，开发还要关注一些工具类的成本
- 减少了多数据库运维成本，减少了很多表
- 删除、修改列: 这些完全与表逻辑解耦，会自动同步这些插入进来的数据，删除，修改列的数据
- 减少了代码量(每个档案的回滚表，repository层,entity层,接口层,有可能的前端层，一些逻辑)
  - 例子：回滚表(repository层,entity层,接口层,有可能的前端层，一些逻辑)
  - 这样这几个层都不要再去写
- 日志表分片提高了日志表的性能
- 项目大类的多表操作
- 多数据库问题
    - 不同公司与不同年度分配数据库的问题
    - 减少了多数据源的连接池内存问题。
- 与多数据库（架构）解耦合
- 开发人员不需要关注多数据库问题和多表问题
- 分片规则基本0风险

## 也许多了一些问题。
- 不能完全独立了
    - 备份删除问题
      - 1级备份：主从完全同步备份删除
        - 都一致
      - 运维手动备份：
        - 现有思路：直接备份（或删除）客户整库
        - 新思路:  备份（或删除）关键表
    - 删库运维(例子：财税达)：
        - 现有思路: - 移除库，删除两个表的关联，该库的连接，通过客户前缀，可以容易实现手动备份或删库操作
        - 新思路: - 移除表，删除两个表的关联，该库的连接，通过客户前缀，可以容易实现关键表的手动备份或删库操作

# 新分区思路
- 最开始看到的postgre 2016 分库分表(年代久远)，但postgre10+以后以（表）分区思路替代分库分表。
## 例子1（凭证）:
1. accvoucher表 
2. 通过2行代码实现了对字段 companyName 和 year 作为条件分区
3. sql：` select * from accvoucher where companyName='xige-001' and year='2020'`
4. 实际上查的是 “accvoucher-xige-001-2020” 这张表

## 例子2（项目大类）:
1. project表
2. 通过2行代码实现了对字段 type 作为条件分区
3. sql：` select * from project where type='01' `
4. 实际上查的是 “project-01” 这张表



# 对比现在的好处：
    - 参照【也许相较现在的模式，我们减少了】
    - 可以1张表实现回滚操作，不用担心性能问题
        - 所有单独回滚表可以删掉了，不用写多个仓库多个实体类多个接口了,不用写多余的回滚表逻辑
    - 简化任务管理和日志
    - 凭证表逻辑不在考虑跨模式问题，摆脱了维护麻烦,条件限制在公司和年度 
        - 影响到总账、明细账、余额表等一系列汇总报表的逻辑
    - 更多无限累计表，可以得到高度性能优化

# 调整方案
## 方案1
    
- 凭证表：
    - 理由：凭证表较常用，调整凭证表和项目大类表到主数据库下,作为分表试点运行
- 项目大类表：
    - 理由：project01 project02 project03 project04 project05 .....很多功能取这个大类时候，这个地方逻辑有很多问题
      如果调整为分表模式，那么只关注project表就可以,`select * from project where type='01' and ....`这个时候查的就是project01分区表


## <span id="jump1">方案2</span>

- 可能具有一定复杂性
- 凭证表在公司账套上：
    - 理由：凭证表较常用，调整凭证表和项目大类表到主数据库下,作为分表试点运行
- 项目大类表在公司账套上：
    - 理由：project01 project02 project03 project04 project05 .....很多功能取这个大类时候，这个地方逻辑有很多问题
      如果调整为分表模式，那么只关注project表就可以,`select * from project where type='01' and ....`这个时候查的就是project01分区表
      

## 方案3
- 数据库重构（唯一数据库架构）
    - 集团库 => 不变
    - 组织库 => 移到集团库以 orgin-**** 前缀定义
    - 模板库 => 前端实现模板逻辑，计算过数据量，几m左右的js数据应该基本够用
    - 账套库 => 不需要账套库,参照凭证表该下所有逻辑移动到集团上



# 问题解决
- 参照【也许多了一些问题】
- 账套年度账审计:
    - 当前思路:直接整模式
    - 新思路:挑表关键表，或者做逻辑功能操作
- 实施维护






   

---

### 例子
#### 账套
- 以单一条件字段切（例子：账套,所有表都加一列作用域）:
  account_schema='xige-001-2020'
#### 项目大类
- 以多字段切（例子：项目大类一张表）：
  type='01'
#### 回滚表

---



### 可能的问题
- 脏数据问题，该问题可以通过回滚表，审计字段，和操作日志得到控制
 




---

# 讨论的草稿
```text


csd模式会越来越多，以重构复杂性，降低多数据库(模式)


该合并，还是该多模式


- 主要问题
完全独立模式的必要性:
    2020年客户档案存在1000条
    2021年原封不动复制下来
    该2020年数据
    冷（2020年客户档案存在1000条） ,  热数据







凭证表不变

回滚表

项目大类


nc-group

bjxgkj
bjxgkj-001-2020
bjxgkj-001-2021
bjxgkj-002-2020
bjxgkj-002-2021

pocobo
pocobo-001-2020
pocobo-001-2021
pocobo-002-2020
pocobo-002-2021


pocobo-001-2018

公用同一套基础档案  2018

600jiakehu

2018   100家客户
2019   130家客户


2018
2019
2020
2021
2022
。。。。


```


本次讨论结束
1. 依旧多数据库架构：账套的所有表在年度上需要完全独立，不能被新年度影响，凭证不建议放到主表，即以现在架构无法做到单数据库架构.
2. 不做大重构，小修改用来postgres分区试点：
    - 凭证表（数据量、一致性的优化）：可以调整凭证表，以方案2（主凭证表在主数据库中，分区在账套数据库架构中）确保凭证表一致性，添加修改删除和列修改操作完全同步
    - 项目大类（逻辑优化）：开发人员仅关注project，不用写一堆实体类工具类，逻辑等，select * from project where type='01',即可在project-01操作
3. 虽然现在的优化没有非常大，但在nc之后下一代框架可以采用 - [【最优方案】](#jump2)。
4. 此次调整更倾向于分区试点，优化的作用没有非常大，调整也比较方便轻松，所以靠后准备，现在不做。



10万条数据
导出数据慢，
